// WARNING: This is an auto-generated file
#include "db_config.h"
#include <cassert>
#include <cstdlib>
#include <iostream>
#include <crypto-old/CryptoManager.hh>
#include <crypto/paillier.hh>
#include <edb/ConnectNew.hh>
#include <execution/encryption.hh>
#include <execution/context.hh>
#include <execution/operator_types.hh>
#include <execution/eval_nodes.hh>
#include <execution/query_cache.hh>
#include <util/util.hh>
class param_generator_id0 : public sql_param_generator {
public:
virtual param_map get_param_map(exec_context& ctx) {
  param_map m;
  {
    Binary key(ctx.crypto->cm->getKey(ctx.crypto->cm->getmkey(), fieldname(1, "SWP"), SECLEVEL::SWP));
    Token t = CryptoManager::token(key, Binary("khaki"));
    m[0] = db_elem((const char *)t.ciph.content, t.ciph.len);
    m[1] = db_elem((const char *)t.wordKey.content, t.wordKey.len);
  }
  return m;
}
};
class param_generator_id1 : public sql_param_generator {
public:
virtual param_map get_param_map(exec_context& ctx) {
  param_map m;
  return m;
}
};
class param_generator_id2 : public sql_param_generator {
public:
virtual param_map get_param_map(exec_context& ctx) {
  param_map m;
  m[0] = ctx.args->columns.at(0);
  m[1] = ctx.args->columns.at(1);
  m[2] = db_elem((int64_t)encrypt_date_ope(ctx.crypto, 1022497 /*1997-1-1*/, 10, false));
  m[3] = db_elem((int64_t)encrypt_date_ope(ctx.crypto, 1023009 /*1998-1-1*/, 10, false));
  return m;
}
};
class param_generator_id3 : public sql_param_generator {
public:
virtual param_map get_param_map(exec_context& ctx) {
  param_map m;
  m[0] = db_elem(encrypt_string_det(ctx.crypto, "ALGERIA", 1, false));
  return m;
}
};
class param_generator_id4 : public sql_param_generator {
public:
virtual param_map get_param_map(exec_context& ctx) {
  param_map m;
  m[0] = db_elem((int64_t)encrypt_u8_det(ctx.crypto, 70 /*F*/, 2, false));
  m[1] = db_elem(encrypt_string_det(ctx.crypto, "IRAN", 1, false));
  return m;
}
};
static void query_0(exec_context& ctx) {
  physical_operator* op = new local_decrypt_op(
    {0, 1},
    new remote_sql_op(new param_generator_id3, "select supplier_enc.s_name_DET, supplier_enc.s_address_DET from supplier_enc, nation_enc where ((supplier_enc.s_suppkey_DET in ( :_subselect$1 )) and ((supplier_enc.s_nationkey_DET) = (nation_enc.n_nationkey_DET))) and ((nation_enc.n_name_DET) = (:0)) order by supplier_enc.s_name_OPE ASC", {db_column_desc(db_elem::TYPE_STRING, 25, oDET, SECLEVEL::DET, 1, false), db_column_desc(db_elem::TYPE_STRING, 40, oDET, SECLEVEL::DET, 2, false)}, {}, util::map_from_pair_vec<std::string, physical_operator*>({std::pair<std::string, physical_operator*>("_subselect$1", new local_transform_op(
      {local_transform_op::trfm_desc(2), },
      new local_filter_op(
        new gt_node(new tuple_pos_node(0), new subselect_node(0, {new tuple_pos_node(1), new tuple_pos_node(2)})),
        new local_decrypt_op(
          {0},
          new remote_sql_op(new param_generator_id1, "select partsupp_enc.ps_availqty_DET, partsupp_enc.ps_partkey_DET, partsupp_enc.ps_suppkey_DET from partsupp_enc where partsupp_enc.ps_partkey_DET in ( :_subselect$0 )", {db_column_desc(db_elem::TYPE_INT, 4, oDET, SECLEVEL::DET, 2, false), db_column_desc(db_elem::TYPE_INT, 4, oDET, SECLEVEL::DETJOIN, 0, false), db_column_desc(db_elem::TYPE_INT, 4, oDET, SECLEVEL::DETJOIN, 1, false)}, {}, util::map_from_pair_vec<std::string, physical_operator*>({std::pair<std::string, physical_operator*>("_subselect$0", new remote_sql_op(new param_generator_id0, "select part_enc.p_partkey_DET from part_enc where searchSWP(:0, :1, part_enc.p_name_SWP)", {db_column_desc(db_elem::TYPE_INT, 4, oDET, SECLEVEL::DETJOIN, 0, false)}, {}, util::map_from_pair_vec<std::string, physical_operator*>({})))})))
        ,{
          new local_transform_op(
            {local_transform_op::trfm_desc(std::make_pair(db_column_desc(db_elem::TYPE_DOUBLE, 8, oNONE, SECLEVEL::PLAIN, 0, false), new mult_node(new double_literal_node(0.500000), new sum_node(new tuple_pos_node(0), false)))), },
            new local_decrypt_op(
              {0},
              new remote_sql_op(new param_generator_id2, "select group_serializer(lineitem_enc.l_quantity_DET) from lineitem_enc where ((((lineitem_enc.l_partkey_DET) = (:0)) and ((lineitem_enc.l_suppkey_DET) = (:1))) and ((lineitem_enc.l_shipdate_OPE) >= (:2))) and ((lineitem_enc.l_shipdate_OPE) < (:3))", {db_column_desc(db_elem::TYPE_DECIMAL_15_2, 15, oDET, SECLEVEL::DET, 4, true)}, {}, util::map_from_pair_vec<std::string, physical_operator*>({})))
          )
          ,
        }
      )
    )
    )})))
  ;
  op->open(ctx);
  while (op->has_more(ctx)) {
    physical_operator::db_tuple_vec v;
    op->next(ctx, v);
    physical_operator::print_tuples(v);
  }
  op->close(ctx);
  delete op;
}
static void query_1(exec_context& ctx) {
  physical_operator* op = new local_limit(100, 
    new local_order_by(
      {std::make_pair(1, true), std::make_pair(0, false)},
      new local_decrypt_op(
        {0},
        new remote_sql_op(new param_generator_id4, "select supplier_enc.s_name_DET, count(*) as numwait from supplier_enc, lineitem_enc l1, orders_enc, nation_enc where ((((((((supplier_enc.s_suppkey_DET) = (l1.l_suppkey_DET)) and ((orders_enc.o_orderkey_DET) = (l1.l_orderkey_DET))) and ((orders_enc.o_orderstatus_DET) = (:0))) and ((l1.l_receiptdate_OPE) > (l1.l_commitdate_OPE))) and (exists ( (select 1 from lineitem_enc l2 where ((l2.l_orderkey_DET) = (l1.l_orderkey_DET)) and ((l2.l_suppkey_DET) <> (l1.l_suppkey_DET))) ))) and (not ( exists ( (select 1 from lineitem_enc l3 where (((l3.l_orderkey_DET) = (l1.l_orderkey_DET)) and ((l3.l_suppkey_DET) <> (l1.l_suppkey_DET))) and ((l3.l_receiptdate_OPE) > (l3.l_commitdate_OPE))) ) ))) and ((supplier_enc.s_nationkey_DET) = (nation_enc.n_nationkey_DET))) and ((nation_enc.n_name_DET) = (:1)) group by supplier_enc.s_name_DET", {db_column_desc(db_elem::TYPE_STRING, 25, oDET, SECLEVEL::DET, 1, false), db_column_desc(db_elem::TYPE_INT, 4, oNONE, SECLEVEL::PLAIN, 0, false)}, {}, util::map_from_pair_vec<std::string, physical_operator*>({})))
    )
  )
  ;
  op->open(ctx);
  while (op->has_more(ctx)) {
    physical_operator::db_tuple_vec v;
    op->next(ctx, v);
    physical_operator::print_tuples(v);
  }
  op->close(ctx);
  delete op;
}
int main(int argc, char **argv) {
  if (argc != 2) {
    std::cerr << "[Usage]: " << argv[0] << " [query num]" << std::endl;
    return 1;
  }
  int q = atoi(argv[1]);
  CryptoManager cm("12345");
  crypto_manager_stub cm_stub(&cm, CRYPTO_USE_OLD_OPE);
  PGConnect pg(DB_HOSTNAME, DB_USERNAME, DB_PASSWORD, DB_DATABASE, DB_PORT, true);
  paillier_cache pp_cache;
  query_cache cache;
  exec_context ctx(&pg, &cm_stub, &pp_cache, NULL, &cache);
  switch (q) {
    case 0: query_0(ctx); break;
    case 1: query_1(ctx); break;
    default: assert(false);
  }
  return 0;
}
